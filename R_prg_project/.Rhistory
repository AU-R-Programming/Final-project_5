# Calculate theoretical wavelet variances using the `wv_theo` function
J <- length(nu_hat)  # J is the length of the empirical wavelet variances
nu_theta <- wv_theo(theta, J)
# Calculate the loss as the weighted squared differences with identity matrix as weighting
# Since Omega = I_J, it is equivalent to the sum of squared differences
loss <- sum((nu_theta - nu_hat)^2)
return(loss)
}
# Assuming `wv_theo` and `gmwm_loss` functions are already defined
gmwm <- function(x, robust = FALSE, start = var(x)) {
# x: the data used to compute empirical wavelet variance
# robust: Boolean indicating whether to use a robust estimator (default is FALSE)
# start: the initial value for optimization (default is the variance of x)
# Load required libraries
library(wv)
library(wavelets)
# Calculate empirical wavelet variance (nu_hat) using the wvar function
if (robust) {
# Use robust estimator
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
# Use standard estimator
nu_hat <- wvar(x, robust = FALSE)$variance
}
# Define the function to minimize: the GMWM loss function
loss_function <- function(theta) {
gmwm_loss(theta, nu_hat)
}
# Use optimization to find the parameter that minimizes the loss function
opt_result <- suppressWarnings(optim(start, loss_function, method = "BFGS"))
# Extract the estimated parameter value
theta_hat <- opt_result$par
return(theta_hat)
}
wv_theo <- function(theta, J) {
# theta: parameter we want to estimate (scalar)
# J: total number of levels of the wavelet variance
# Define dimension d
d <- length(theta)
# Identity matrix of dimension d
Id <- diag(d)
# Initialize a vector to store the wavelet variances for each level j
wavelet_variances <- numeric(J)
# Loop over each level j = 1,...,J
for (j in 1:J) {
# Define A_j as the product of filter coefficients
# For simplicity, we assume A_j as identity matrix of appropriate dimension
A_j <- diag(d)
# Calculate Σ(θ) = I_d * theta
Sigma_theta <- Id * theta
# Compute the trace of A_j * Σ(θ)
trace_value <- sum(diag(A_j %*% Sigma_theta))
# Compute theoretical wavelet variance for level j
wavelet_variances[j] <- trace_value / (2^j)
}
return(wavelet_variances)
}
# Assuming `wv_theo` function is already defined as per Question 1
gmwm_loss <- function(theta, nu_hat) {
# theta: parameter to estimate
# nu_hat: J x 1 vector of empirical wavelet variances
# Calculate theoretical wavelet variances using the `wv_theo` function
J <- length(nu_hat)  # J is the length of the empirical wavelet variances
nu_theta <- wv_theo(theta, J)
# Calculate the loss as the weighted squared differences with identity matrix as weighting
# Since Omega = I_J, it is equivalent to the sum of squared differences
loss <- sum((nu_theta - nu_hat)^2)
return(loss)
}
# Assuming `wv_theo` and `gmwm_loss` functions are already defined
gmwm <- function(x, robust = FALSE, start = var(x)) {
# x: the data used to compute empirical wavelet variance
# robust: Boolean indicating whether to use a robust estimator (default is FALSE)
# start: the initial value for optimization (default is the variance of x)
# Load required libraries
library(wv)
library(wavelets)
# Calculate empirical wavelet variance (nu_hat) using the wvar function
if (robust) {
# Use robust estimator
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
# Use standard estimator
nu_hat <- wvar(x, robust = FALSE)$variance
}
# Define the function to minimize: the GMWM loss function
loss_function <- function(theta) {
gmwm_loss(theta, nu_hat)
}
# Use optimization to find the parameter that minimizes the loss function
opt_result <- suppressWarnings(optim(start, loss_function, method = "BFGS"))
# Extract the estimated parameter value
theta_hat <- opt_result$par
return(theta_hat)
}
# Load necessary libraries
library(MASS)
library(wv)
library(wavelets)
# Assuming `gmwm` function is already defined
# Initialize parameters
B <- 100           # Number of replications
d <- 1000          # Sample size
true_theta <- 2    # True parameter value
cont <- 10         # Number of contaminated observations
# Initialize vectors to store results for each estimation
theta_Xt_std <- numeric(B)
theta_Xt_rob <- numeric(B)
theta_Zt_std <- numeric(B)
theta_Zt_rob <- numeric(B)
# Simulation study
set.seed(123)  # Set seed for reproducibility
for (b in 1:B) {
# Generate sample X^(b) from N(0, I_d * true_theta)
X <- MASS::mvrnorm(n = d, mu = rep(0, d), Sigma = diag(d) * true_theta)
# Create a contaminated copy Z^(b) by modifying 10 randomly selected observations
Z <- X
random_indices <- sample(1:d, cont)  # Randomly select 10 indices
Z[random_indices] <- rexp(cont, rate = 0.5)  # Replace with values from exponential distribution
# Estimate parameter for X^(b) with standard and robust estimators
theta_Xt_std[b] <- gmwm(X, robust = FALSE)
theta_Xt_rob[b] <- gmwm(X, robust = TRUE)
# Estimate parameter for Z^(b) with standard and robust estimators
theta_Zt_std[b] <- gmwm(Z, robust = FALSE)
theta_Zt_rob[b] <- gmwm(Z, robust = TRUE)
}
wv_theo <- function(theta, J) {
# theta: parameter we want to estimate (scalar)
# J: total number of levels of the wavelet variance
# Define dimension d
d <- length(theta)
# Identity matrix of dimension d
Id <- diag(d)
# Initialize a vector to store the wavelet variances for each level j
wavelet_variances <- numeric(J)
# Loop over each level j = 1,...,J
for (j in 1:J) {
# Define A_j as the product of filter coefficients
# For simplicity, we assume A_j as identity matrix of appropriate dimension
A_j <- diag(d)
# Calculate Σ(θ) = I_d * theta
Sigma_theta <- Id * theta
# Compute the trace of A_j * Σ(θ)
trace_value <- sum(diag(A_j %*% Sigma_theta))
# Compute theoretical wavelet variance for level j
wavelet_variances[j] <- trace_value / (2^j)
}
return(wavelet_variances)
}
# Assuming `wv_theo` function is already defined as per Question 1
gmwm_loss <- function(theta, nu_hat) {
# theta: parameter to estimate
# nu_hat: J x 1 vector of empirical wavelet variances
# Calculate theoretical wavelet variances using the `wv_theo` function
J <- length(nu_hat)  # J is the length of the empirical wavelet variances
nu_theta <- wv_theo(theta, J)
# Calculate the loss as the weighted squared differences with identity matrix as weighting
# Since Omega = I_J, it is equivalent to the sum of squared differences
loss <- sum((nu_theta - nu_hat)^2)
return(loss)
}
# Assuming `wv_theo` and `gmwm_loss` functions are already defined
gmwm <- function(x, robust = FALSE, start = var(x)) {
# x: the data used to compute empirical wavelet variance
# robust: Boolean indicating whether to use a robust estimator (default is FALSE)
# start: the initial value for optimization (default is the variance of x)
# Load required libraries
library(wv)
library(wavelets)
# Calculate empirical wavelet variance (nu_hat) using the wvar function
if (robust) {
# Use robust estimator
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
# Use standard estimator
nu_hat <- wvar(x, robust = FALSE)$variance
}
# Define the function to minimize: the GMWM loss function
loss_function <- function(theta) {
gmwm_loss(theta, nu_hat)
}
# Use optimization to find the parameter that minimizes the loss function
opt_result <- suppressWarnings(optim(start, loss_function, method = "BFGS"))
# Extract the estimated parameter value
theta_hat <- opt_result$par
return(theta_hat)
}
# Load necessary libraries
library(MASS)
library(wv)
library(wavelets)
# Assuming `gmwm` function is already defined
# Initialize parameters
B <- 100           # Number of replications
d <- 1000          # Sample size
true_theta <- 2    # True parameter value
cont <- 10         # Number of contaminated observations
# Initialize vectors to store results for each estimation
theta_Xt_std <- numeric(B)
theta_Xt_rob <- numeric(B)
theta_Zt_std <- numeric(B)
theta_Zt_rob <- numeric(B)
# Simulation study
set.seed(123)  # Set seed for reproducibility
for (b in 1:B) {
# Generate sample X^(b) from N(0, I_d * true_theta)
X <- MASS::mvrnorm(n = d, mu = rep(0, d), Sigma = diag(d) * true_theta)
# Create a contaminated copy Z^(b) by modifying 10 randomly selected observations
Z <- X
random_indices <- sample(1:d, cont)  # Randomly select 10 indices
Z[random_indices] <- rexp(cont, rate = 0.5)  # Replace with values from exponential distribution
# Estimate parameter for X^(b) with standard and robust estimators
theta_Xt_std[b] <- gmwm(X, robust = FALSE)
theta_Xt_rob[b] <- gmwm(X, robust = TRUE)
# Estimate parameter for Z^(b) with standard and robust estimators
theta_Zt_std[b] <- gmwm(Z, robust = FALSE)
theta_Zt_rob[b] <- gmwm(Z, robust = TRUE)
}
wv_theo <- function(theta, J) {
# theta: parameter we want to estimate (scalar)
# J: total number of levels of the wavelet variance
# Define dimension d
d <- length(theta)
# Identity matrix of dimension d
Id <- diag(d)
# Initialize a vector to store the wavelet variances for each level j
wavelet_variances <- numeric(J)
# Loop over each level j = 1,...,J
for (j in 1:J) {
# Define A_j as the product of filter coefficients
# For simplicity, we assume A_j as identity matrix of appropriate dimension
A_j <- diag(d)
# Calculate Σ(θ) = I_d * theta
Sigma_theta <- Id * theta
# Compute the trace of A_j * Σ(θ)
trace_value <- sum(diag(A_j %*% Sigma_theta))
# Compute theoretical wavelet variance for level j
wavelet_variances[j] <- trace_value / (2^j)
}
return(wavelet_variances)
}
# Assuming `wv_theo` function is already defined as per Question 1
gmwm_loss <- function(theta, nu_hat) {
# theta: parameter to estimate
# nu_hat: J x 1 vector of empirical wavelet variances
# Calculate theoretical wavelet variances using the `wv_theo` function
J <- length(nu_hat)  # J is the length of the empirical wavelet variances
nu_theta <- wv_theo(theta, J)
# Calculate the loss as the weighted squared differences with identity matrix as weighting
# Since Omega = I_J, it is equivalent to the sum of squared differences
loss <- sum((nu_theta - nu_hat)^2)
return(loss)
}
# Assuming `wv_theo` and `gmwm_loss` functions are already defined
gmwm <- function(x, robust = FALSE, start = var(x)) {
# x: the data used to compute empirical wavelet variance
# robust: Boolean indicating whether to use a robust estimator (default is FALSE)
# start: the initial value for optimization (default is the variance of x)
# Load required libraries
library(wv)
library(wavelets)
# Calculate empirical wavelet variance (nu_hat) using the wvar function
if (robust) {
# Use robust estimator
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
# Use standard estimator
nu_hat <- wvar(x, robust = FALSE)$variance
}
# Define the function to minimize: the GMWM loss function
loss_function <- function(theta) {
gmwm_loss(theta, nu_hat)
}
# Use optimization to find the parameter that minimizes the loss function
opt_result <- suppressWarnings(optim(start, loss_function, method = "BFGS"))
# Extract the estimated parameter value
theta_hat <- opt_result$par
return(theta_hat)
}
# Load necessary libraries
library(MASS)
library(wv)
library(wavelets)
# Assuming `gmwm` function is already defined
# Initialize parameters
B <- 100           # Number of replications
d <- 1000          # Sample size
true_theta <- 2    # True parameter value
cont <- 10         # Number of contaminated observations
# Initialize vectors to store results for each estimation
theta_Xt_std <- numeric(B)
theta_Xt_rob <- numeric(B)
theta_Zt_std <- numeric(B)
theta_Zt_rob <- numeric(B)
# Simulation study
set.seed(123)  # Set seed for reproducibility
for (b in 1:B) {
# Generate sample X^(b) from N(0, I_d * true_theta) - Ensure X is a one-dimensional vector
X <- MASS::mvrnorm(n = d, mu = rep(0, 1), Sigma = matrix(true_theta, 1, 1))
# Create a contaminated copy Z^(b) by modifying 10 randomly selected observations
Z <- X
random_indices <- sample(1:d, cont)  # Randomly select 10 indices
Z[random_indices] <- rexp(cont, rate = 0.5)  # Replace with values from exponential distribution
# Estimate parameter for X^(b) with standard and robust estimators
theta_Xt_std[b] <- gmwm(X, robust = FALSE)
theta_Xt_rob[b] <- gmwm(X, robust = TRUE)
# Estimate parameter for Z^(b) with standard and robust estimators
theta_Zt_std[b] <- gmwm(Z, robust = FALSE)
theta_Zt_rob[b] <- gmwm(Z, robust = TRUE)
}
# Compute Median Absolute Error (MAE) for each estimator
mae_Xt_std <- median(abs(theta_Xt_std - true_theta))
mae_Xt_rob <- median(abs(theta_Xt_rob - true_theta))
mae_Zt_std <- median(abs(theta_Zt_std - true_theta))
mae_Zt_rob <- median(abs(theta_Zt_rob - true_theta))
# Print MAEs
print(paste("MAE for X^(b) with standard estimator:", mae_Xt_std))
print(paste("MAE for X^(b) with robust estimator:", mae_Xt_rob))
print(paste("MAE for Z^(b) with standard estimator:", mae_Zt_std))
print(paste("MAE for Z^(b) with robust estimator:", mae_Zt_rob))
# Create boxplots for each estimator to visualize the results
boxplot(theta_Xt_std, theta_Xt_rob, theta_Zt_std, theta_Zt_rob,
names = c("X (Standard)", "X (Robust)", "Z (Standard)", "Z (Robust)"),
main = "Parameter Estimates for Standard and Robust GMWM",
ylab = "Estimated Theta",
col = c("lightblue", "lightgreen", "orange", "pink"))
abline(h = true_theta, col = "red", lwd = 2, lty = 2)
# Comment on the results:
# The standard estimator for X^(b) generally provides estimates close to the true parameter value (theta_0 = 2).
# However, in the presence of contamination (in Z^(b)), the standard estimator shows significant bias and variability.
# This is reflected in the higher MAE for Z^(b) with the standard estimator, indicating that contamination has a large negative effect.
# The robust estimator performs better in contaminated settings (Z^(b)), showing less bias and more consistency in estimates.
# The robust estimator for both X^(b) and Z^(b) has lower MAE values compared to the standard estimator in contaminated settings,
# suggesting that it is more resistant to the influence of outliers.
library(wv)
library(wavelets)
wv_theo <- function(theta, J) {
# defining dimension d
d <- length(theta)
# identity matrix for d dimensions
Id <- diag(d)
# J is the levels
# create vector to store variences for j levels
wavelet_variances <- numeric(J)
for (j in 1:J) {
#store and assume a_j as identity matric
a_j <- diag(d)
# Calculate Σ(θ) = I_d * theta
Sigma_theta <- Id * theta
# Compute the trace of A_j * Σ(θ)
trace_value <- sum(diag(A_j %*% Sigma_theta))
# Compute theoretical wavelet variance for level j
wavelet_variances[j] <- trace_value / (2^j)
}
return(wavelet_variances)
}
#2
gmwm_loss <- function(theta, nu_hat) {
# calculating theo_variance using  wv_theo function
# create j has empirical varaiance length
J <- length(nu_hat)
nu_theta <- wv_theo(theta, J)
# calculate loss
loss <- sum((nu_theta - nu_hat)^2)
return(loss)
}
#3
gmwm <- function(x, robust = FALSE, start = var(x)) {
# calculating empirical wavelet function using wvar from wv pacakage
if (robust) {
# robust estimator
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
#standard estimator
nu_hat <- wvar(x, robust = FALSE)$variance
}
#minimize loss
loss_function <- function(theta) {
gmwm_loss(theta, nu_hat)
}
#finding parameter which minimize loss function using optim func
optimization_result <- suppressWarnings(optim(start, loss_function, method = "BFGS"))
theta_hat <- optimization_result$par
return(theta_hat)
}
#load library
library(MASS)
# given paramters
B <- 100
d <- 1000
true_theta <- 2
cont <- 10
# storing the result of each estimation
theta_Xt_std <- numeric(B)
theta_Xt_rob <- numeric(B)
theta_Zt_std <- numeric(B)
theta_Zt_rob <- numeric(B)
set.seed(123)
for (b in 1:B) {
#generating sample x using mvrnorm
X <- MASS::mvrnorm(n = d, mu = rep(0, 1), Sigma = matrix(true_theta, 1, 1))
# creating contiminated from x by modifying adding randomly selected indices
Z <- X
random_indices <- sample(1:d, cont)
Z[random_indices] <- rexp(cont, rate = 0.5)
# estimations of paramters of x and z with standard and random estimators
theta_Xt_std[b] <- gmwm(X, robust = FALSE)
theta_Xt_rob[b] <- gmwm(X, robust = TRUE)
theta_Zt_std[b] <- gmwm(Z, robust = FALSE)
theta_Zt_rob[b] <- gmwm(Z, robust = TRUE)
}
library(wv)
library(wavelets)
wv_theo <- function(theta, J) {
# defining dimension d
d <- length(theta)
# identity matrix for d dimensions
Id <- diag(d)
# J is the levels
# create vector to store variences for j levels
wavelet_variances <- numeric(J)
for (j in 1:J) {
#store and assume a_j as identity matric
a_j <- diag(d)
# Calculate Σ(θ) = I_d * theta
Sigma_theta <- Id * theta
# Compute the trace of a_j * Σ(θ)
trace_value <- sum(diag(a_j %*% Sigma_theta))
# Compute theoretical wavelet variance for level j
wavelet_variances[j] <- trace_value / (2^j)
}
return(wavelet_variances)
}
#2
gmwm_loss <- function(theta, nu_hat) {
# calculating theo_variance using  wv_theo function
# create j has empirical varaiance length
J <- length(nu_hat)
nu_theta <- wv_theo(theta, J)
# calculate loss
loss <- sum((nu_theta - nu_hat)^2)
return(loss)
}
#3
gmwm <- function(x, robust = FALSE, start = var(x)) {
# calculating empirical wavelet function using wvar from wv pacakage
if (robust) {
# robust estimator
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
#standard estimator
nu_hat <- wvar(x, robust = FALSE)$variance
}
#minimize loss
loss_function <- function(theta) {
gmwm_loss(theta, nu_hat)
}
#finding parameter which minimize loss function using optim func
optimization_result <- suppressWarnings(optim(start, loss_function, method = "BFGS"))
theta_hat <- optimization_result$par
return(theta_hat)
}
#load library
library(MASS)
# given paramters
B <- 100
d <- 1000
true_theta <- 2
cont <- 10
# storing the result of each estimation
theta_Xt_std <- numeric(B)
theta_Xt_rob <- numeric(B)
theta_Zt_std <- numeric(B)
theta_Zt_rob <- numeric(B)
set.seed(123)
for (b in 1:B) {
#generating sample x using mvrnorm
X <- MASS::mvrnorm(n = d, mu = rep(0, 1), Sigma = matrix(true_theta, 1, 1))
# creating contiminated from x by modifying adding randomly selected indices
Z <- X
random_indices <- sample(1:d, cont)
Z[random_indices] <- rexp(cont, rate = 0.5)
# estimations of paramters of x and z with standard and random estimators
theta_Xt_std[b] <- gmwm(X, robust = FALSE)
theta_Xt_rob[b] <- gmwm(X, robust = TRUE)
theta_Zt_std[b] <- gmwm(Z, robust = FALSE)
theta_Zt_rob[b] <- gmwm(Z, robust = TRUE)
}
#5
#computing MEA for two estimators having data  x and z
mae_Xt_std <- median(abs(theta_Xt_std - true_theta))
mae_Xt_rob <- median(abs(theta_Xt_rob - true_theta))
mae_Zt_std <- median(abs(theta_Zt_std - true_theta))
mae_Zt_rob <- median(abs(theta_Zt_rob - true_theta))
# boxplot for each estimator with x and contaminated z
boxplot(theta_Xt_std, theta_Xt_rob, theta_Zt_std, theta_Zt_rob,
names = c("X (Standard)", "X (Robust)", "Z (Standard)", "Z (Robust)"),
main = "parameters estimates for standard amd robust ",
ylab = "estimated theta",
col = c("lightblue", "lightgreen", "orange", "pink"))
abline(h = true_theta, col = "red", lwd = 2, lty = 2)
# commnents on both estimator behaviour
#the standard estimor performs well with x on close to true value
# robust show similar performance with x but we expected to show more perfromance.
# on z(contaminated), the  standard estimator showing higher mea and  bias i noticed because of the outlier
# robust estimator shows  that is closer to true valueon z and x on comparing it has lower bias and mea values for both x and z
getwd()
devtools::build_vignettes()
setwd("~/GitHub/Final-project_5/R_prg_project")
devtools::build_vignettes()
devtools::build_vignettes()
rlang::last_trace()
